name: Application CI Pipeline

on: [push]
  
jobs:
  # ==================================================================
  # Job pour analyser le code (Frontend et Backend en parallèle)
  # ==================================================================
  code-analysis:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Définit les modules à analyser
        module: [quiz-app, backend]
    
    steps:
      - name: 1. Checkout Code
        uses: actions/checkout@v4

      - name: 2. Scan for Leaked Secrets with Gitleaks
        uses: gitleaks/gitleaks-action@v2
        with:
          # Échoue si des secrets sont trouvés
          fail: false

      - name: 3. Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: 4. Install Dependencies for ${{ matrix.module }}
        run: npm install
        working-directory: ./${{ matrix.module }}

      - name: 5. Run Linter & Tests for ${{ matrix.module }}
        run: |
          npm run lint
          npm test
        working-directory: ./${{ matrix.module }}
        env:
          CI: true

      - name: 6. Scan Application Code with Semgrep (SAST)
        uses: returntocorp/semgrep-action@v1
        with:
          # Scanne uniquement le répertoire du module concerné
          sourceRoot: ./${{ matrix.module }}

      - name: 7. Scan Dependencies with OWASP Dependency-Check (SCA)
        # Vous pouvez utiliser une action du marketplace ou un script custom
        # C'est une étape qui peut être longue, à optimiser si besoin
        run: echo "Exécution de OWASP Dependency-Check sur ${{ matrix.module }}"
        # Ici, vous intégreriez l'appel à l'outil OWASP DC

  # ==================================================================
  # Job pour construire et scanner les images (après succès de l'analyse)
  # ==================================================================
  build-and-scan-image:
    needs: code-analysis # Dépend du succès du job précédent
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Nécessaire pour l'authentification OIDC avec AWS
      security-events: write # Pour envoyer les résultats de Trivy à GitHub
    
    strategy:
      matrix:
        # Définit les images à construire
        module: [frontend, backend]

    steps:
      - name: 1. Checkout Code
        uses: actions/checkout@v4

      - name: 2. Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role # Rôle IAM pour GHA
          aws-region: ${{ secrets.AWS_REGION }}

      - name: 3. Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: 4. Build, Tag, and Push Image to ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/${{ matrix.module }}:$IMAGE_TAG .
          docker push $ECR_REGISTRY/${{ matrix.module }}:$IMAGE_TAG
          echo "image_uri=$ECR_REGISTRY/${{ matrix.module }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
        working-directory: ./${{ matrix.module }}

      - name: 5. Scan Pushed Image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.build-image.outputs.image_uri }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH' # La pipeline échouera si des vulnérabilités de ce niveau sont trouvées
          # Trivy peut aussi scanner les dépendances (SCA) et les misconfigurations
          scanners: vuln,secret,config

# Note : Le déploiement avec ArgoCD est déclenché par une mise à jour du dépôt GitOps,
# qui serait une étape finale dans cette pipeline ou dans une pipeline de déploiement séparée.
