# .github/workflows/continousIntegration.yaml (Version mise à jour)
name: CI/CD with Staging, DAST, and Production Promotion
on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'quiz-app/**'
      - 'kubernetes-manifest/**'
      - 'kubernetes-manifest-staging/**'
  pull_request:   # ✅ Ajout
    branches:
      - main
    paths:
      - 'backend/**'
      - 'quiz-app/**'
      - 'kubernetes-manifest/**'
      - 'kubernetes-manifest-staging/**'

env:
  AWS_REGION: "us-east-1"
  ECR_REPOSITORY_BACKEND: "iovision-repo"
  ECR_REPOSITORY_FRONTEND: "quiz-app-repo"
  ECR_REPOSITORY_POPULATE: "populate-repo" 

jobs:
  # ===================================================================
  # JOBS DE TESTS ET D'ANALYSE STATIQUE (INCHANGÉS)
  # ===================================================================
  frontend-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./quiz-app
    strategy:
      matrix:
        node-version: [20.x]
        architecture: [x64]
    steps:
      - name: Check-out git repository  
        uses: actions/checkout@v4
      - name: USE NODEJS ${{ matrix.node-version }} - ${{ matrix.architecture }}
        uses: actions/setup-node@v4
      - name: Install project dependencies 
        run: |
          npm i
          npm run lint
          npm install --save-dev --save-exact prettier
          npm run prettier
          npm test
        env:
          CI: true 
      - name: Build
        run: npm run build

  backend-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    strategy:
      matrix:
        node-version: [20.x]
        architecture: [x64]
    steps:
      - name: Check-out git repository  
        uses: actions/checkout@v4
      - name: USE NODEJS ${{ matrix.node-version }} - ${{ matrix.architecture }}
        uses: actions/setup-node@v4
      - name: Install project dependencies 
        run: |
          npm i
          npm run lint
          npm install --save-dev --save-exact prettier
          npm run prettier
          npm test
        env:
          CI: true 

  semgrep-scan-frontend:
    needs: frontend-test
    name: Semgrep Analysis (quiz-app only)
    runs-on: ubuntu-latest
    container:
      image: returntocorp/semgrep
    defaults:
      run:
        working-directory: ./quiz-app
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Run Semgrep scan (with JSON report)
        run: semgrep scan --config auto . --json --output semgrep-report-frontend.json
      - name: Upload Semgrep JSON report
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-json-frontend-report
          path: ./quiz-app/semgrep-report-frontend.json

  gitleaks-scan-frontend:
    needs: frontend-test
    name: Gitleaks Analysis (quiz-app only)
    runs-on: ubuntu-latest
    container:
      image: zricethezav/gitleaks:latest
    defaults:
      run:
        working-directory: ./quiz-app
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Mark GitHub workspace as safe
        run: git config --global --add safe.directory $GITHUB_WORKSPACE
      - name: Run Gitleaks scan on quiz-app
        run: gitleaks detect --source . --no-git --verbose --report-format json --report-path gitleaks-report-frontend.json
        continue-on-error: true
      - name: Upload Gitleaks JSON report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-json-frontend-report
          path: ./quiz-app/gitleaks-report-frontend.json
    
  dependency-check-frontend:
    needs: frontend-test
    name: OWASP Dependency-Check (quiz-app)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          cache-dependency-path: 'quiz-app/package-lock.json'
      - name: Install dependencies for analysis
        working-directory: ./quiz-app
        run: npm install
      - name: Run OWASP Dependency-Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'quiz-app-frontend'
          path: './quiz-app'
          format: 'HTML'
          out: 'reports-frontend'
          args: >
            --scan .
            --enableExperimental
            --disableOssIndex

      - name: Upload Dependency-Check report
        uses: actions/upload-artifact@v4
        with:
          name: owasp-dep-check-frontend-report
          path: reports-frontend
        
  semgrep-scan-backend:
    needs: backend-test
    name: Semgrep Analysis 
    runs-on: ubuntu-latest
    container:
      image: returntocorp/semgrep
    defaults:
      run:
        working-directory: ./backend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Run Semgrep scan 
        run: semgrep scan --config auto . --json --output semgrep-report-backend.json
      - name: Upload Semgrep JSON report
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-json-report
          path: ./backend/semgrep-report-backend.json

  gitleaks-scan-backend:
    needs: backend-test
    name: Gitleaks Analysis 
    runs-on: ubuntu-latest
    container:
      image: zricethezav/gitleaks:latest
    defaults:
      run:
        working-directory: ./backend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Mark GitHub workspace as safe
        run: git config --global --add safe.directory $GITHUB_WORKSPACE
      - name: Run Gitleaks scan on backend
        run: gitleaks detect --source . --no-git --verbose --report-format json --report-path gitleaks-report-backend.json
        continue-on-error: true
      - name: Upload Gitleaks JSON report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-json-report
          path: ./backend/gitleaks-report-backend.json
  
  dependency-check-backend:
    needs: backend-test
    name: OWASP Dependency-Check (backend)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
          cache: 'npm'
          cache-dependency-path: 'backend/package-lock.json'
      - name: Install dependencies for analysis
        working-directory: ./backend
        run: npm install
      - name: Run OWASP Dependency-Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'quiz-app-backend'
          path: './backend'
          format: 'HTML'
          out: 'reports-backend'
          args: >
            --scan .
            --enableExperimental
            --disableOssIndex

      - name: Upload Dependency-Check report
        uses: actions/upload-artifact@v4
        with:
          name: owasp-dep-check-backend-report
          path: reports-backend

  # ===================================================================
  # JOB MODIFIÉ : BUILD & PUSH BACKEND + POPULATE
  # ===================================================================
  # ===================================================================
  # ÉTAPE 1 : BUILD, PUSH & CRÉATION DES ARTEFACTS
  # ===================================================================

  build-backend:
    name: "Build & Push: Backend"
    # Les dépendances (needs) restent les mêmes
    needs: [semgrep-scan-backend, gitleaks-scan-backend, dependency-check-backend]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    # ### CHANGEMENT : On supprime la section 'outputs'. L'output sera l'artefact.
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::228578233417:role/oicd
          aws-region:  ${{ env.AWS_REGION }}
      - id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # ### CHANGEMENT : Cette étape définit le tag et le pousse dans une variable d'environnement du job
      - name: "Define Backend Image Tag"
        id: define-tag
        run: |
          SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-8)
          IMAGE_TAG="backend-${SHA_SHORT}"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
          echo "image_tag_output=${IMAGE_TAG}" >> $GITHUB_OUTPUT # Pour l'étape de scan trivy

      - name: "Build and Push Backend Image"
        run: |
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_URI="$ECR_REGISTRY/${{ env.ECR_REPOSITORY_BACKEND }}:${{ env.IMAGE_TAG }}"
          docker build -t $IMAGE_URI ./backend
          docker push $IMAGE_URI
      
      - name: "Scan image with Trivy"
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: "${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_BACKEND }}:${{ steps.define-tag.outputs.image_tag_output }}"
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

      # ### NOUVEAU : On crée un fichier contenant le tag et on le sauvegarde comme artefact.
      - name: "Save Backend Tag to Artifact"
        run: echo "${{ env.IMAGE_TAG }}" > backend_tag.txt
      - uses: actions/upload-artifact@v4
        with:
          name: backend-tag-artifact # Nom unique pour cet artefact
          path: backend_tag.txt

  build-frontend:
    name: "Build & Push: Frontend"
    # Dépend des tests et scans du frontend
    needs: [frontend-test, semgrep-scan-frontend, gitleaks-scan-frontend, dependency-check-frontend]
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Permission pour se connecter à AWS

    steps:
      # Étape 1 : Récupérer le code
      - name: "Checkout repository"
        uses: actions/checkout@v4

      # Étape 2 : Se connecter à AWS et à ECR
      - name: "Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::228578233417:role/oicd
          aws-region:  ${{ env.AWS_REGION }}
      - name: "Log in to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Étape 3 : Définir le tag, construire l'image, la pousser et la scanner
      - name: "Define, Build, Push & Scan Frontend"
        id: build-push-frontend
        run: |
          # Définit un tag unique basé sur le hash du commit
          SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-8)
          IMAGE_TAG="frontend-${SHA_SHORT}"
          
          # Prépare l'URI complet de l'image
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_URI="$ECR_REGISTRY/${{ env.ECR_REPOSITORY_FRONTEND }}:${IMAGE_TAG}"
          
          echo "Building and pushing image: $IMAGE_URI"
          
          # Construit l'image Docker à partir du dossier 'quiz-app'
          docker build -t $IMAGE_URI ./quiz-app
          
          # Pousse l'image vers le registre ECR
          docker push $IMAGE_URI
          
          # Sauvegarde le tag et l'URI pour les étapes suivantes (scan et artefact)
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV

      - name: "Scan Frontend image with Trivy"
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMAGE_URI }}
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

      # Étape 4 : Créer l'artefact pour passer le tag au job de déploiement
      - name: "Save Frontend Tag to Artifact"
        run: echo "${{ env.IMAGE_TAG }}" > frontend_tag.txt
      - uses: actions/upload-artifact@v4
        with:
          name: frontend-tag-artifact # Nom unique pour l'artefact du frontend
          path: frontend_tag.txt


  build-populate:
    name: "Build & Push: Populate"
    # Dépend des tests et scans du backend, car il partage le même code source
    needs: [backend-test, semgrep-scan-backend, gitleaks-scan-backend, dependency-check-backend]
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Permission pour se connecter à AWS

    steps:
      # Étape 1 : Récupérer le code
      - name: "Checkout repository"
        uses: actions/checkout@v4

      # Étape 2 : Se connecter à AWS et à ECR
      - name: "Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::228578233417:role/oicd
          aws-region:  ${{ env.AWS_REGION }}
      - name: "Log in to Amazon ECR"
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Étape 3 : Définir le tag, construire l'image, la pousser et la scanner
      - name: "Define, Build, Push & Scan Populate"
        id: build-push-populate
        run: |
          # Définit un tag unique basé sur le hash du commit
          SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-8)
          IMAGE_TAG="populate-${SHA_SHORT}"
          
          # Prépare l'URI complet de l'image
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_URI="$ECR_REGISTRY/${{ env.ECR_REPOSITORY_POPULATE }}:${IMAGE_TAG}"
          
          echo "Building and pushing image: $IMAGE_URI"
          
          # Construit l'image en spécifiant le Dockerfile pour le script de peuplement
          docker build -t $IMAGE_URI -f ./backend/Dockerfile.populate ./backend
          
          # Pousse l'image vers le registre ECR
          docker push $IMAGE_URI
          
          # Sauvegarde le tag et l'URI pour les étapes suivantes
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV

      - name: "Scan Populate image with Trivy"
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMAGE_URI }}
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

      # Étape 4 : Créer l'artefact pour passer le tag au job de déploiement
      - name: "Save Populate Tag to Artifact"
        run: echo "${{ env.IMAGE_TAG }}" > populate_tag.txt
      - uses: actions/upload-artifact@v4
        with:
          name: populate-tag-artifact # Nom unique pour l'artefact du populate
          path: populate_tag.txt

  # ===================================================================
  # JOB 3: UPDATE MANIFESTS (MODIFIÉ)
  # ===================================================================
  # ===================================================================


  deploy-to-staging:
    name: "Deploy to Staging"
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, build-populate]
    permissions:
      contents: write
    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v4
        with: 
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: "Download All Image Tag Artifacts"
        uses: actions/download-artifact@v4
        with:
          path: artifacts/ 
      - name: "Update and Push Staging Manifests"
        run: |
          git pull origin main --rebase

          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions-bot@github.com'
          BACKEND_TAG=$(cat artifacts/backend-tag-artifact/backend_tag.txt)
          FRONTEND_TAG=$(cat artifacts/frontend-tag-artifact/frontend_tag.txt)
          POPULATE_TAG=$(cat artifacts/populate-tag-artifact/populate_tag.txt)
          sed -i "s|\(image: .*iovision-repo:\).*|\1${BACKEND_TAG}|" kubernetes-manifest-staging/backend.yaml
          sed -i "s|\(image: .*quiz-app-repo:\).*|\1${FRONTEND_TAG}|" kubernetes-manifest-staging/frontend.yaml
          sed -i "s|\(image: .*populate-repo:\).*|\1${POPULATE_TAG}|" kubernetes-manifest-staging/populate-job.yaml
          git add kubernetes-manifest-staging/
          if git diff --cached --quiet; then
            echo "No changes to staging manifests to commit."
          else
            git commit -m "ci(staging): Deploy image tags for commit ${{ github.sha }}"
            git push
          fi

  # ===================================================================
  # ÉTAPE 3 : TESTS SUR STAGING (DAST)
  # Ce job attend que le déploiement soit effectif, puis teste.
  # ===================================================================
  test-staging:
    name: "DAST on Staging"
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    steps:
      - name: "Wait for Staging URL to be available"
        run: |
          echo "Waiting 2 minutes for ArgoCD to sync changes..."
          sleep 120
          echo "Checking Staging URL: https://quiz.iovision.site"
          end_time=$(( $(date +%s) + 600 ))
          while true; do
            status_code=$(curl --insecure --head -s -o /dev/null -w '%{http_code}' https://quiz.iovision.site )
            if [ "$status_code" -eq 200 ]; then
              echo "Success! Staging URL is responding with status 200."
              break
            fi
            if [ $(date +%s) -gt $end_time ]; then
              echo "::warning::Timeout: Staging URL did not become available. Continuing anyway."
              break
            fi
            echo "Staging URL not ready (Status: $status_code). Retrying in 20 seconds..."
            sleep 20
          done
      - name: "Run OWASP ZAP Full Scan"
        uses: zaproxy/action-full-scan@v0.12.0
        with:
          target: https://quiz.iovision.site
          fail_action: false
          allow_issue_writing: false
          artifact_name: 'zap-scan-report'
          token: ${{ secrets.GITHUB_TOKEN }}

  # ===================================================================
  # ÉTAPE 4 : PROMOTION EN PRODUCTION
  # Ce job final met à jour les manifestes de production.
  # ===================================================================
  promote-to-production:
    name: "Promote to Production"
    runs-on: ubuntu-latest
    needs: test-staging
    # On ajoute un environnement pour pouvoir mettre une approbation manuelle plus tard
    environment: 
      name: production
      url: https://quiz.iovision.site
    permissions:
      contents: write
    steps:
      - name: "Checkout repository"
        uses: actions/checkout@v4
        with: 
         token: ${{ secrets.GITHUB_TOKEN }} 
      - name: "Download All Image Tag Artifacts"
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
      - name: "Update and Push Production Manifests"
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions-bot@github.com'        
          git pull origin main --rebase
          BACKEND_TAG=$(cat artifacts/backend-tag-artifact/backend_tag.txt )
          FRONTEND_TAG=$(cat artifacts/frontend-tag-artifact/frontend_tag.txt)
          POPULATE_TAG=$(cat artifacts/populate-tag-artifact/populate_tag.txt)         
          sed -i "s|\(image: .*iovision-repo:\).*|\1${BACKEND_TAG}|" kubernetes-manifest/backend.yaml
          sed -i "s|\(image: .*quiz-app-repo:\).*|\1${FRONTEND_TAG}|" kubernetes-manifest/frontend.yaml
          sed -i "s|\(image: .*populate-repo:\).*|\1${POPULATE_TAG}|" kubernetes-manifest/populate-job.yaml         
          git add kubernetes-manifest/
          if git diff --cached --quiet; then
            echo "No changes to production manifests to commit."
          else
            git commit -m "ci(prod): Promote image tags for commit ${{ github.sha }}"
            git push
          fi
  k8s-manifest-scan:
    name: "Scan K8s Manifests (Checkov & Kubescape)"
    needs: promote-to-production
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4        
      - name: Run Checkov scan on production manifests
        uses: bridgecrewio/checkov-action@master   
        with:
          directory: ./kubernetes-manifest
          framework: kubernetes
          output_format: json
          output_file_path: ./checkov-report.json
          soft_fail: true 
      - name: Upload Checkov JSON report
        uses: actions/upload-artifact@v4
        with:
          name: checkov-k8s-report
          path: ./checkov-report.json        
      - name: Run Kubescape scan on production manifests
        uses: kubescape/github-action@main   
        with:
          files: "kubernetes-manifest/*.yaml"
          format: json
          outputFile: ./kubescape-report.json
        continue-on-error: true
      - name: Upload Kubescape JSON report
        uses: actions/upload-artifact@v4
        with:
          name: kubescape-k8s-report
          path: ./kubescape-report.json
  gitleaks-scan-manifests:
    name: "Gitleaks Scan on K8s Manifests"
    needs: promote-to-production
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4       
      - name: Run Gitleaks scan on kubernetes-manifest
        uses: gitleaks/gitleaks-action@v2
        with:
          path: ./kubernetes-manifest        
      - name: Upload Gitleaks report
        if: failure() 
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-k8s-report
          path: gitleaks-report.json
