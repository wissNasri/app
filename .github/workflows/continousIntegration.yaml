name: React.js CI + Semgrep

on:
  # 1. Déclenchement automatique sur push vers la branche main
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - 'quiz-app/**'
      - 'kubernetes-manifest/**'
      - 'kubernetes-manifest-staging/**' # Ajouté pour être complet
      - '.github/workflows/**' # Bonne pratique pour redéclencher si la pipeline change

  # 2. NOUVEAU : Permet le déclenchement manuel depuis l'interface GitHub
  workflow_dispatch:



env:
  AWS_REGION: "us-east-1"
  ECR_REPOSITORY_BACKEND: "iovision-repo"
  ECR_REPOSITORY_FRONTEND: "quiz-app-repo"
  ECR_REPOSITORY_POPULATE: "populate-repo" # NOUVEAU : Variable pour le nouveau dépôt ECR

jobs:
  # ===================================================================
  # JOBS DE TESTS ET D'ANALYSE STATIQUE (INCHANGÉS)
  # ===================================================================
  frontend-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./quiz-app
    strategy:
      matrix:
        node-version: [20.x]
        architecture: [x64]
    steps:
      - name: Check-out git repository  
        uses: actions/checkout@v4
      - name: USE NODEJS ${{ matrix.node-version }} - ${{ matrix.architecture }}
        uses: actions/setup-node@v4
      - name: Install project dependencies 
        run: |
          npm i
          npm run lint
          npm install --save-dev --save-exact prettier
          npm run prettier
          npm test
        env:
          CI: true 
      - name: Build
        run: npm run build

  backend-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    strategy:
      matrix:
        node-version: [20.x]
        architecture: [x64]
    steps:
      - name: Check-out git repository  
        uses: actions/checkout@v4
      - name: USE NODEJS ${{ matrix.node-version }} - ${{ matrix.architecture }}
        uses: actions/setup-node@v4
      - name: Install project dependencies 
        run: |
          npm i
          npm run lint
          npm install --save-dev --save-exact prettier
          npm run prettier
          npm test
        env:
          CI: true 

  semgrep-scan-frontend:
    needs: frontend-test
    name: Semgrep Analysis (quiz-app only)
    runs-on: ubuntu-latest
    container:
      image: returntocorp/semgrep
    defaults:
      run:
        working-directory: ./quiz-app
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Run Semgrep scan (with JSON report)
        run: semgrep scan --config auto . --json --output semgrep-report-frontend.json
      - name: Upload Semgrep JSON report
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-json-frontend-report
          path: ./quiz-app/semgrep-report-frontend.json

  gitleaks-scan-frontend:
    needs: frontend-test
    name: Gitleaks Analysis (quiz-app only)
    runs-on: ubuntu-latest
    container:
      image: zricethezav/gitleaks:latest
    defaults:
      run:
        working-directory: ./quiz-app
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Mark GitHub workspace as safe
        run: git config --global --add safe.directory $GITHUB_WORKSPACE
      - name: Run Gitleaks scan on quiz-app
        run: gitleaks detect --source . --no-git --verbose --report-format json --report-path gitleaks-report-frontend.json
        continue-on-error: true
      - name: Upload Gitleaks JSON report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-json-frontend-report
          path: ./quiz-app/gitleaks-report-frontend.json
    
 
        
  semgrep-scan-backend:
    needs: backend-test
    name: Semgrep Analysis 
    runs-on: ubuntu-latest
    container:
      image: returntocorp/semgrep
    defaults:
      run:
        working-directory: ./backend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Run Semgrep scan 
        run: semgrep scan --config auto . --json --output semgrep-report-backend.json
      - name: Upload Semgrep JSON report
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-json-report
          path: ./backend/semgrep-report-backend.json

  gitleaks-scan-backend:
    needs: backend-test
    name: Gitleaks Analysis 
    runs-on: ubuntu-latest
    container:
      image: zricethezav/gitleaks:latest
    defaults:
      run:
        working-directory: ./backend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Mark GitHub workspace as safe
        run: git config --global --add safe.directory $GITHUB_WORKSPACE
      - name: Run Gitleaks scan on backend
        run: gitleaks detect --source . --no-git --verbose --report-format json --report-path gitleaks-report-backend.json
        continue-on-error: true
      - name: Upload Gitleaks JSON report
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-json-report
          path: ./backend/gitleaks-report-backend.json


  # ===================================================================
  # JOB MODIFIÉ : BUILD & PUSH BACKEND + POPULATE
  # ===================================================================
  build-backend:
    needs: [semgrep-scan-frontend,gitleaks-scan-frontend,semgrep-scan-backend,gitleaks-scan-backend]
    name: "Build & Push: Backend " # MODIFIÉ : Titre du job
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    outputs:
      image_tag_backend: ${{ steps.vars-backend.outputs.image_tag }} # MODIFIÉ : Nom de l'output

    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::228578233417:role/oicd
          aws-region: ${{ env.AWS_REGION }}
      - uses: aws-actions/amazon-ecr-login@v2
        id: login-ecr

      - name: Define Backend Image Tag
        id: vars-backend # MODIFIÉ : ID de l'étape
        run: |
          SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-8)
          IMAGE_TAG="backend-${SHA_SHORT}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Build and Push Backend Image
        id: build-image-backend # MODIFIÉ : ID de l'étape
        run: |
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ steps.vars-backend.outputs.image_tag }}"
          docker build -t $IMAGE_URI ./backend
          docker push $IMAGE_URI
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Scan BACKEND image with Trivy
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.build-image-backend.outputs.image_uri }}
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

      # --- NOUVEAU : Étapes pour l'image populate ---


  build-populate:
    needs: [semgrep-scan-frontend,gitleaks-scan-frontend,semgrep-scan-backend,gitleaks-scan-backend]
    name: "Build & Push:  Populate" # MODIFIÉ : Titre du job
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    outputs:
      image_tag_populate: ${{ steps.vars-populate.outputs.image_tag }} # NOUVEAU : Output pour l'image populate

    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::228578233417:role/oicd
          aws-region: ${{ env.AWS_REGION }}
      - uses: aws-actions/amazon-ecr-login@v2
        id: login-ecr

      - name: Define Populate Image Tag
        id: vars-populate
        run: |
          SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-8)
          IMAGE_TAG="populate-${SHA_SHORT}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Build and Push Populate Image
        id: build-image-populate
        run: |
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY_POPULATE:${{ steps.vars-populate.outputs.image_tag }}"
          docker build -t $IMAGE_URI -f ./backend/Dockerfile.populate ./backend
          docker push $IMAGE_URI
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Scan POPULATE image with Trivy
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.build-image-populate.outputs.image_uri }}
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

  # ===================================================================
  # JOB 2: BUILD & PUSH FRONTEND (INCHANGÉ)
  # ===================================================================
  build-frontend:
    name: "Build & Push: Frontend"
    needs: [semgrep-scan-frontend,gitleaks-scan-frontend,semgrep-scan-backend,gitleaks-scan-backend]
  
    runs-on: ubuntu-latest
    permissions: { id-token: write }
    outputs:
      image_tag: ${{ steps.vars-frontend.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::228578233417:role/oicd
          aws-region: ${{ env.AWS_REGION }}
      - uses: aws-actions/amazon-ecr-login@v2
        id: login-ecr
      - name: "Define Frontend Image Tag"
        id: vars-frontend
        run: |
          SHA_SHORT=$(echo ${{ github.sha }} | cut -c1-8)
          echo "image_tag=frontend-${SHA_SHORT}" >> $GITHUB_OUTPUT
      - name: "Build, Push & Scan Frontend for Staging"
        run: |
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_URI="$ECR_REGISTRY/${{ env.ECR_REPOSITORY_FRONTEND }}:${{ steps.vars-frontend.outputs.image_tag }}"
          
          docker build -t $IMAGE_URI ./quiz-app
          docker push $IMAGE_URI
          echo "IMAGE_URI_FOR_SCAN=$IMAGE_URI" >> $GITHUB_ENV
      - name: "Scan Image with Trivy"
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMAGE_URI_FOR_SCAN }}
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
  



  # ===================================================================
  # JOB 3: UPDATE MANIFESTS (MODIFIÉ)
  # ===================================================================
  # ===================================================================
  # DÉPLOIEMENT EN STAGING ET SCAN DAST
  # ===================================================================
  update-manifests-staging:
    name: "Deploy to Staging: Update Manifests"
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, build-populate] # Dépend toujours des builds
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Update staging manifests and push to Git
        run: |
          git config --global user.name 'wissNasri'
          git config --global user.email 'wissemnasri81@gmail.com'
          
          BACKEND_TAG=${{ needs.build-backend.outputs.image_tag_backend }}
          POPULATE_TAG=${{ needs.build-populate.outputs.image_tag_populate }}
          FRONTEND_TAG=${{ needs.build-frontend.outputs.image_tag }}
          
          # Mise à jour des manifestes dans le dossier de STAGING
          sed -i "s|\(image: .*/${{ env.ECR_REPOSITORY_BACKEND }}:\).*|\1$BACKEND_TAG|" kubernetes-manifest-staging/backend.yaml
          sed -i "s|\(image: .*/${{ env.ECR_REPOSITORY_FRONTEND }}:\).*|\1$FRONTEND_TAG|" kubernetes-manifest-staging/frontend.yaml
          sed -i "s|\(image: .*/${{ env.ECR_REPOSITORY_POPULATE }}:\).*|\1$POPULATE_TAG|" kubernetes-manifest-staging/populate-job.yaml
          
          git add kubernetes-manifest-staging/
          
          if git diff --cached --quiet; then
            echo "No changes to commit for staging."
          else
            git commit -m "ci(staging): Deploy images for commit ${{ github.sha }}"
            git push
          fi

  # ===================================================================
  # NOUVEAUX JOBS : Attente du déploiement et Scan DAST
  # ===================================================================
  wait-for-staging-deployment:
    name: "Wait for Staging URL"
    runs-on: ubuntu-latest
    needs: update-manifests-staging # Se lance après la mise à jour des manifestes de staging
    steps:
      - name: "Wait for application to become available"
        run: |
          echo "Waiting 2 minutes for ArgoCD sync and ALB initialization..."
          sleep 120
          echo "Checking staging URL availability..."
          curl --retry 18 --retry-delay 10 --retry-connrefused --silent --show-error --fail "https://quiz-staging.iovision.site"
          echo "Staging URL is now accessible!"

  dast-scan:
    name: "DAST Scan (Staging)"
    runs-on: ubuntu-latest
    needs: wait-for-staging-deployment # Se lance après que l'URL est prête
    steps:
      - name: "Run OWASP ZAP Full Scan"
        uses: zaproxy/action-full-scan@v0.12.0
        with:
          # L'URL de votre application à scanner
          target: 'https://quiz-staging.iovision.site'
          
          # --- MODIFICATIONS CLÉS ---
          
          # 1. Ne pas faire échouer le pipeline en cas d'alertes
          fail_action: false
          
          # 2. Ne pas créer d'issue sur GitHub
          allow_issue_writing: false
          
          # --- PARAMÈTRES OPTIONNELS (TOUJOURS UTILES ) ---
          
          # Génère un rapport que vous pouvez télécharger et consulter
          artifact_name: 'zap-scan-report'
          
          # Le token n'est plus nécessaire si allow_issue_writing est false,
          # mais le laisser ne pose pas de problème.
          token: ${{ secrets.GITHUB_TOKEN }}

  # ===================================================================
  # MODIFICATION : Vos jobs de scan de manifestes dépendent maintenant du DAST
  # pour s'assurer qu'ils s'exécutent à la fin du flux de validation.
  # ===================================================================
  k8s-manifest-scan:
    needs: dast-scan # MODIFIÉ : Dépend du succès du DAST
    # ... (le reste de votre job est inchangé )
    name: "Scan Kubernetes Manifests"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Checkov scan
        uses: bridgecrewio/checkov-action@master
        with: { directory: './kubernetes-manifest', framework: 'kubernetes' }
        continue-on-error: true
      - name: Run Kubescape scan
        uses: kubescape/github-action@main
        with: { files: 'kubernetes-manifest/*.yaml' }
        continue-on-error: true

  gitleaks-scan-manifests:
    needs: dast-scan # MODIFIÉ : Dépend du succès du DAST
    # ... (le reste de votre job est inchangé)
    name: Gitleaks Analysis (kubernetes-manifest)
    runs-on: ubuntu-latest
    container: { image: 'zricethezav/gitleaks:latest' }
    defaults: { run: { working-directory: ./kubernetes-manifest } }
    steps:
      - uses: actions/checkout@v4
      - run: git config --global --add safe.directory $GITHUB_WORKSPACE
      - run: gitleaks detect --source . --no-git --verbose
        continue-on-error: true

  # ===================================================================
  # NOUVEAU JOB : Promotion manuelle vers la Production
  # ===================================================================


  # ... (votre pipeline existante jusqu'à la fin des scans)

  # ===================================================================
  # JOB 4 : DÉPLOIEMENT MANUEL EN PRODUCTION
  # ===================================================================
  update-manifests-production:
    name: "Promote to Production: Update Manifests"
    runs-on: ubuntu-latest
    # Ce job ne s'exécute QUE sur déclenchement manuel via workflow_dispatch
    if: github.event_name == 'workflow_dispatch'
    
    # Il a besoin des tags d'images des builds précédents
    needs: [build-backend, build-frontend, build-populate]
    
    permissions:
      contents: write # Nécessaire pour pousser les modifications

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # On s'assure de récupérer tout l'historique pour pouvoir pousser
          fetch-depth: 0 

      - name: Update production manifests and push to Git
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions-bot@github.com'
          
          # Récupération des tags d'images des jobs de build
          BACKEND_TAG=${{ needs.build-backend.outputs.image_tag_backend }}
          POPULATE_TAG=${{ needs.build-populate.outputs.image_tag_populate }}
          FRONTEND_TAG=${{ needs.build-frontend.outputs.image_tag }}
          
          echo "Promoting to production with the following tags:"
          echo "Backend: $BACKEND_TAG"
          echo "Frontend: $FRONTEND_TAG"
          echo "Populate: $POPULATE_TAG"

          # Mise à jour des manifestes dans le dossier de PRODUCTION
          sed -i "s|\(image: .*/${{ env.ECR_REPOSITORY_BACKEND }}:\).*|\1$BACKEND_TAG|" kubernetes-manifest/backend.yaml
          sed -i "s|\(image: .*/${{ env.ECR_REPOSITORY_FRONTEND }}:\).*|\1$FRONTEND_TAG|" kubernetes-manifest/frontend.yaml
          sed -i "s|\(image: .*/${{ env.ECR_REPOSITORY_POPULATE }}:\).*|\1$POPULATE_TAG|" kubernetes-manifest/populate-job.yaml
          
          # Ajout des fichiers modifiés au commit
          git add kubernetes-manifest/
          
          # Commit et push uniquement s'il y a des changements
          if git diff --cached --quiet; then
            echo "No changes to commit for production. Manifests are already up-to-date."
          else
            git commit -m "ci(prod): Promote images to production for commit ${{ github.sha }}"
            git push
            echo "Production manifests updated successfully!"
          fi
 
